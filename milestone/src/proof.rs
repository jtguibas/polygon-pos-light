use alloy_rlp::Decodable;
use reth_primitives::revm_primitives::bitvec::macros::internal::funty::Fundamental;

pub struct Proof {}

impl Proof {
    pub fn checkProof(header_hexs: Vec<String>) -> bool {
        let header_bytes0 = hex::decode(header_hexs[0].as_str()).unwrap_or_default();
        let h0 = reth_primitives::Header::decode(&mut header_bytes0.as_slice()).unwrap();
        if h0.number.as_u64() != 3887749 {
            return false;
        }


        let header_bytes1 = hex::decode(header_hexs[1].as_str()).unwrap_or_default();
        let h1 = reth_primitives::Header::decode(&mut header_bytes1.as_slice()).unwrap();
        if h1.number.as_u64() != 3887750 {
            return false;
        }
        true
    }
}

#[cfg(test)]
mod test {
    use crate::proof::Proof;

    #[test]
    fn test_proof() {
        let check = Proof::checkProof(
            vec![
                "f9025ba07fd311189e40a776db15f4b6bc0e4fceed937614eea20dca968b73b4444613c3a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0d779a24664fd354017a7469607dee3faa87ef4978112d1c8e958b2a5ec7d52f4a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421b901000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008833b52858401c9c380808465da406eb861d88301010083626f7289676f312e32302e3132856c696e757800000000000000aa28c83c8be63349a69ca5d761963a1cec82d0cae01eac9c5c7de3ac68517bb30e2628da2c0e5e97d2749e91d03b24759bcaf1dc5e286e7a658206676d32a4d001a000000000000000000000000000000000000000000000000000000000000000008800000000000000000f".to_string(),
                "f9025ba0940ea75d7320c80328bcc113524e267b1a48a0530761cf1117769dcdd657d64ba01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0d779a24664fd354017a7469607dee3faa87ef4978112d1c8e958b2a5ec7d52f4a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421b901000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008833b52868401c9c380808465da4070b861d88301010083626f7289676f312e32302e3132856c696e7578000000000000008e45f0ce0bac37c915bf64a48673b005efaba0dc90ab5d628160af6dad92df9f03f2bc018d7de93482f12d6895e428c587cff31ba0951afa5fdbfd8d778faa9800a000000000000000000000000000000000000000000000000000000000000000008800000000000000000f".to_string()]
        );
        assert_eq!(check, true);
    }
}