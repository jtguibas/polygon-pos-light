pub type EthAddress = [u8; 20];

#[cfg(test)]
mod test {
    use alloy_rlp::Decodable;
    use reth_primitives::revm_primitives::bitvec::macros::internal::funty::Fundamental;

    #[test]
    fn test_decode() {
        let header_bytes = hex::decode("f9025ba07fd311189e40a776db15f4b6bc0e4fceed937614eea20dca968b73b4444613c3a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0d779a24664fd354017a7469607dee3faa87ef4978112d1c8e958b2a5ec7d52f4a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421b901000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008833b52858401c9c380808465da406eb861d88301010083626f7289676f312e32302e3132856c696e757800000000000000aa28c83c8be63349a69ca5d761963a1cec82d0cae01eac9c5c7de3ac68517bb30e2628da2c0e5e97d2749e91d03b24759bcaf1dc5e286e7a658206676d32a4d001a000000000000000000000000000000000000000000000000000000000000000008800000000000000000f").unwrap_or_default();
        let h = reth_primitives::Header::decode(&mut header_bytes.as_slice()).unwrap();
        assert_eq!(h.number.as_u64(), 3887749);
        println!("{}", h.hash_slow().to_string())
    }

    use reth_primitives::{keccak256, recover_signer_unchecked};

    #[test]
    fn test_ecrecover() {
        let sig = [0u8; 65];
        let hash = [0u8; 32];
        let addr = recover_signer_unchecked(&sig, &hash).unwrap_or_default();
        assert_eq!(addr.to_string(), "0x0000000000000000000000000000000000000000");

        let sig_bytes = hex::decode("32f2a7ee00f089c49c79ca8a9615278586b60385bb4bd8d0a23ee9a99fae315a3a304d0f21047c35ee4ba2d69d7fb4a23e68f24c70dafb73828e6a1d7ee4d66901").unwrap_or_default();
        let mut data_bytes = hex::decode("0000000000000000000000004ad84f7014b7b44f723f284a85b166233797143900000000000000000000000000000000000000000000000000000000003b528500000000000000000000000000000000000000000000000000000000003b52926f73bdeda24c8d6b978628e10c425f5a8bbf181a547dafdf5eb156135626728e00000000000000000000000000000000000000000000000000000000000138820000000000000000000000000000000000000000000000000000000000000000").unwrap_or_default();
        data_bytes.insert(0, 1);

        let mut sig2 = [0u8; 65];
        sig2.copy_from_slice(sig_bytes.as_slice());

        let addr2 = recover_signer_unchecked(&sig2, &keccak256(data_bytes)).unwrap_or_default();
        assert_eq!(addr2.to_string(), "0xbb583A9Dde59Ca64AaA14807f37A4C665C0d72c7")
    }
}